#include <bits/stdc++.h>
#define endl '\n';
using namespace std;

typedef long long ll;
/**
 * 第一眼写法是枚举区间长度然后把每个区间的f[s]算出来并加一起，但这做法是n^2显然超时，所以我们就换个思路。
 * 我们可以计算每个字符的贡献，并计算他们的贡献和。怎么计算贡献呢？
 * 因为区间内重复的字符只算一个，所以对于样例ababc中第一个a字母来说，
 * 它能被计数的情况就是从上一个字母a开始（因为没有所以实际上是从它开始），
 * 区间长度从1到len的len种情况（虽然到第3个位置也有个字符a，但我们只记录一个，
 * 所以记录的还是最先出现的a），那么第一个字母a所能提供的贡献一共就是len，即5。
 * 我们再看第二个字母a，和前面说的一样，他能被计数的情况，
 * 就是从上一个相同的字母开始，枚举区间长度直到到达字符串末尾，
 * 所以第二个字母所能提供的贡献就是：（当前字母位置 - 上一个相同字母）*（区间长度 - 当前字母位置）=2 *3=6；
 * 我们只要如法炮制，求得所有字符的贡献，并把计算贡献的总和即可。
 * 虽然看似要找上一个相同字母的位置有点麻烦，但实际上我们用一个哈希表或者26长度的数组就可以，
 * 专门记录上一个相同字符出现的位置，因为一开始还没有相同的字符所以初始化为-1）
 */

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);
    string str;
    cin >> str;
    int a[26];
    memset(a, -1, sizeof a);
    ll res = 0;
    int n = str.length();
    for (int i = 0; i < n; i++)
    {
        res += (i - a[str[i]-'a']) * (n - i);
        a[str[i] - 'a'] = i;
    }
    cout << res << endl;
    return 0;
}
